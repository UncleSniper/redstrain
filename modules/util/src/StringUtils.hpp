#ifndef REDSTRAIN_MOD_UTIL_STRINGUTILS_HPP
#define REDSTRAIN_MOD_UTIL_STRINGUTILS_HPP

#include <list>
#include <deque>
#include <string>
#include <vector>
#include <sstream>

#include "Appender.hpp"

/**
 * @file
 * Definition of the @link redengine::util::StringUtils string processing
 * functions @endlink.
 *
 * @since 0.1.0
 */

namespace redengine {
namespace util {

	/**
	 * String processing functions. This class defines some functions
	 * @c std::string sadly lacks.
	 *
	 * @since 0.1.0
	 */
	class StringUtils {

	  public:
		/**
		 * Flags to be passed to string processing functions.
		 * A number of the functions in StringUtils allow passing
		 * a "flags" argument, which is the bitwise disjunction
		 * of any subset of the constants defined by <tt>Flags</tt>.
		 *
		 * @see
		 * @link trim(const std::string&, const unsigned char*, int) trim@endlink,
		 * @link split(const std::string&, const std::string&, Appender<std::string>&, int) split@endlink
		 * @since 0.1.0
		 */
		enum Flags {
			/**
			 * Omit leading optional elements. In situations where
			 * elements of a sequence may be skipped, this flag
			 * indicates that any prefix of skippable elements
			 * should be dropped from the sequence.
			 *
			 * @since 0.1.0
			 */
			TRIM_FRONT      = 001,
			/**
			 * Omit trailing optional elements. In situations where
			 * elements of a sequence may be skipped, this flag
			 * indicates that any suffix of skippable elements
			 * should be dropped from the sequence.
			 *
			 * @since 0.1.0
			 */
			TRIM_BACK       = 002,
			/**
			 * Omit internal optional elements. In situations where
			 * elements of a sequence may be skipped, this flag
			 * indicates that any subsequence of non-leading, non-trailing
			 * elements (i.e. any subsequence that is neither a prefix
			 * not a suffix) should be dropped from the sequence.
			 *
			 * @since 0.1.0
			 */
			TRIM_CENTER     = 004,
			/**
			 * Emit separator elements. In situations where a sequence
			 * is generated by emitting elements separated by some
			 * separator, this flag indicates that any separator
			 * should be considered an element as well and be emitted
			 * accordingly.
			 *
			 * @since 0.1.0
			 */
			KEEP_SEPARATORS = 010
		};

	  public:
		/**
		 * Trim table for whitespace characters. This
		 * @link #trim(const std::string&, const unsigned char*, int) table@endlink
		 * has bits set corresponding to the characters
		 * commonly considered "whitespace", namely tabulation
		 * (@c '\\t'), newline (@c '\\n'), form feed (@c '\\f'),
		 * carriage return (@c '\\r') and space (@c ' ').
		 *
		 * @see trim(const std::string&, const unsigned char*, int)
		 * @since 0.1.0
		 */
		static const unsigned char WHITESPACE[32];

	  public:
		static bool startsWith(const std::string&, const std::string&);
		static bool endsWith(const std::string&, const std::string&);
		static void split(const std::string&, const std::string&, Appender<std::string>&, int = 0);
		static std::string join(const std::list<std::string>&, const std::string& = "", const std::string& = "");
		static std::string join(const std::deque<std::string>&, const std::string& = "", const std::string& = "");
		static std::string join(const std::vector<std::string>&, const std::string& = "", const std::string& = "");
		static std::string trim(const std::string&, int = TRIM_FRONT | TRIM_BACK);
		static std::string trim(const std::string&, const std::string&, int = TRIM_FRONT | TRIM_BACK);
		static std::string trim(const std::string&, const unsigned char*, int = TRIM_FRONT | TRIM_BACK);
		static void prepareTrim(const std::string&, unsigned char*);
		static std::string replaceFirst(const std::string&, char, char);
		static std::string replaceFirst(const std::string&, const std::string&, const std::string&);
		static std::string replaceAll(const std::string&, char, char);
		static std::string replaceAll(const std::string&, const std::string&, const std::string&);
		static std::string toUpperCase(const std::string&);
		static std::string toLowerCase(const std::string&);
		static std::string capitalize(const std::string&);
		static std::string capitalizeAll(const std::string&);

		/**
		 * Join a sequence of strings into one string. The
		 * @c first and @c last arguments represent iterators
		 * over the sequence of strings to join. A local copy
		 * typed @c IteratorT of @c first called @c current is
		 * created by means of copy-construction. As long as
		 * <tt>current != last</tt>, the
		 * return value of <tt>*current</tt>, which must be
		 * a valid initializer for a <tt>std::string&</tt>, is
		 * appended to the (initially empty) result string,
		 * unless that value is the empty string, in which
		 * case @c emptyReplacement is appended instead. The
		 * iterator is then advanced to the next element in
		 * the sequence by issuing <tt>++current</tt>. Between
		 * any two adjacent string so appended, @c glue is
		 * appended.
		 *
		 * The result string is thus constructed as:
		 * @code
		   for(; current != last; ++current) {
		       if(current != first)
		           result.append(glue);
		       result.append(current->empty() ? emptyReplacement : *current);
		   }
		 * @endcode
		 *
		 * @param first iterator pointing to the first element
		 * of the sequence of strings to join
		 * @param last iterator pointing to just after the last
		 * element of the sequence of strings to join; @c last
		 * must be @em reachable from @c first by the STL definition
		 * of an <em>input iterator</em>.
		 * @param glue string to insert between two elements of
		 * the sequence
		 * @param emptyReplacement string to insert instead of
		 * empty elements of the sequence
		 * @return a string constructed according to the above
		 * algorithm, containing the elements of the sequence
		 * interspersed with @c glue
		 *
		 * @tparam IteratorT type of sequence iterators @c first
		 * and @c last
		 * @tparconstr
		 * - @c IteratorT must satisfy the STL requirement of
		 *   an <em>input iterator</em>, except that postincrement
		 *   is not required.
		 *
		 * @since 0.1.0
		 */
		template<typename IteratorT>
		static std::string joinAll(const IteratorT& first, const IteratorT& last, const std::string& glue = "",
				const std::string& emptyReplacement = "") {
			std::string result;
			IteratorT it(first);
			for(; it != last; ++it) {
				if(it != first)
					result.append(glue);
				result.append(it->empty() ? emptyReplacement : *it);
			}
			return result;
		}

		/**
		 * Convert an object to a string. This conversion
		 * is performed according to STL formatted output
		 * to an <tt>ostream</tt>.
		 *
		 * @param object the object to convert to a string
		 * @return the string representation of @c object
		 *
		 * @tparam ObjectT the type of the object to be converted
		 * @tparconstr
		 * - The object must be printable to a @c std::ostream
		 *   using the formatted output "shift" operator, i.e.
		 *   there must exist
		 *   <tt>operator<<(std::ostream&, const ObjectT&)</tt>.
		 *
		 * @since 0.1.0
		 */
		template<typename ObjectT>
		static std::string toString(const ObjectT& object) {
			std::stringstream ss;
			ss << object;
			return ss.str();
		}

	};

}}

#endif /* REDSTRAIN_MOD_UTIL_STRINGUTILS_HPP */
